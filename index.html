<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>wfir&#39;s tech blog</title>
  <meta name="author" content="wfir">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="wfir&#39;s tech blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wfir&#39;s tech blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">wfir&#39;s tech blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-23T08:08:22.000Z"><a href="/2016/06/23/使用Perf和FlameGraph进行系统性能分析/">2016-06-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/23/使用Perf和FlameGraph进行系统性能分析/">使用Perf和FlameGraph进行系统性能分析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Perf是一款Linux平台的系统性能诊断和分析工具,通过它可以查看应用程序的运行性能,只是在图形方面表现的不足,好在有Flame Graph.Flame Graph能够把Perf采集的数据转换为svg矢量图.<br>本文就简单说说它们的用法.</p>
<p><strong>Perf</strong></p>
<ol>
<li><p>Perf安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y perf</span><br></pre></td></tr></table></figure>
</li>
<li><p>Perf使用</p>
</li>
</ol>
<ul>
<li>perf list<br>  列出所有perf能够采样点的事件</li>
<li>perf stat<br>  以精简的方式提供被调试程序的整体情况和汇总数据</li>
<li>perf top<br>  列出所有进程,实时显示统计信息</li>
<li>perf record<br>  记录单个函数级别的统计信息</li>
<li>perf report<br>  显示统计结果</li>
</ul>
<p><strong>Flame Graph</strong><br>FLame Graph其实是一组perl脚本,用以将perf等工具获取的原始采样数据转换为Flame Graph能够识别的文件格式,除了perf,还支持Dtrace,Systemtap以及XCode Instruments等工具.<br>Flame Graph能够生成svg矢量图,X轴代表采样总量,Y轴代表栈深度.每个框代表一个栈里的函数,宽度代表占用CPU的总时间.较宽的框表示该函数运行时间较慢或调用次数较多,从而占用CPU时间多.</p>
<ul>
<li>Flame Graph脚本列表<blockquote>
<p>flamegraph.pl<br>stackcollapse-elfutils.pl<br>stackcollapse-gdb.pl<br>stackcollapse-instruments.pl<br>stackcollapse-jstack.pl<br>stackcollapse-perf.pl<br>stackcollapse.pl<br>stackcollapse-pmc.pl<br>stackcollapse-recursive.pl<br>stackcollapse-stap.pl<br>stackcollapse-vtune.pl</p>
</blockquote>
</li>
</ul>
<p><strong>使用示例</strong></p>
<ol>
<li><p>使用perf record生成采样数据perf.data</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf record <span class="operator">-a</span> -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用perf script对perf.data进行解析</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf script -i perf.data &amp;&gt; perf.unfold</span><br></pre></td></tr></table></figure>
</li>
<li><p>将perf.unfold中的符号进行折叠</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成svg图</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>参考站点</strong></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-perf1</a><br><a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="external">https://github.com/brendangregg/FlameGraph</a><br><a href="http://kernel.taobao.org/index.php?title=Documents/Perf_flame_graph" target="_blank" rel="external">http://kernel.taobao.org/index.php?title=Documents/Perf_flame_graph</a><br><a href="http://unix.stackexchange.com/questions/14227/do-i-need-root-admin-permissions-to-run-userspace-perf-tool-perf-events-ar" target="_blank" rel="external">http://unix.stackexchange.com/questions/14227/do-i-need-root-admin-permissions-to-run-userspace-perf-tool-perf-events-ar</a><br><a href="https://gist.github.com/trevnorris/9616784" target="_blank" rel="external">https://gist.github.com/trevnorris/9616784</a><br><a href="http://www.infoq.com/cn/news/2015/08/java-flamegraph" target="_blank" rel="external">http://www.infoq.com/cn/news/2015/08/java-flamegraph</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-20T07:27:24.000Z"><a href="/2016/06/20/Nginx配置模板/">2016-06-20</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/20/Nginx配置模板/">Nginx配置模板</a></h1>
  

    </header>
    <div class="entry">
      
        <p>工作中用Nginx的地方很多,每次部署好后都面临Nginx的配置问题.这里把工作中用到的Nginx配置整理成模板,方便今后查阅.</p>
<p>Nginx配置文件分为3种:</p>
<ol>
<li>Nginx主配置文件<ul>
<li>nginx.conf   包含全局配置</li>
</ul>
</li>
<li>Server配置文件<ul>
<li>server.conf  包含server访问规则</li>
</ul>
</li>
<li>Upstream配置文件<ul>
<li>upstream.conf    包含后端服务器信息 </li>
</ul>
</li>
</ol>
<p>各个文件内容如下:</p>
<p><strong>nginx.conf</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user  nginx nginx ;&#10;worker_processes  auto;&#10;#error_log  logs/error.log;&#10;pid        logs/nginx.pid;&#10;worker_rlimit_nofile 102400;&#10;&#10;events &#123;&#10;use epoll;&#10;multi_accept on;&#10;worker_connections 10240;&#10;&#125;&#10;&#10;http &#123;&#10;include mime.types;&#10;default_type  application/octet-stream;&#10;charset UTF-8;&#10;log_format  main  &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;&#10;                  &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;&#10;                  &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39; &#39;$request_time&#39; &#39;$upstream_addr&#39;;&#10;#access_log  logs/access.log  main;&#10;sendfile        on;&#10;tcp_nopush     on;&#10;server_tokens off;&#10;keepalive_timeout  65;&#10;&#10;gzip on;&#10;gzip_proxied any;&#10;gzip_comp_level 4;&#10;gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;&#10;gzip_min_length 1k;&#10;gzip_buffers 4 16k;&#10;gzip_http_version 1.1;&#10;gzip_vary on;&#10;&#10;client_max_body_size 10m;&#10;client_body_buffer_size 128k;&#10;&#10;proxy_connect_timeout 60;&#9;&#10;proxy_read_timeout 60;&#10;proxy_send_timeout 60;&#10;proxy_buffer_size 16k;&#10;proxy_buffers 4 32k;&#10;proxy_busy_buffers_size&#160;64k;&#160;&#10;proxy_temp_file_write_size&#160;128k;&#160;&#10;&#10;#include&#25991;&#20214;&#36335;&#24452;&#20197;&#23454;&#38469;&#36335;&#24452;&#20026;&#20934;&#10;include /app/nginx/conf/vhost/server.conf;&#10;include /app/nginx/conf/vhost/upstream.conf;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>server.conf</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server &#123;&#10;listen       80;&#9;                            #or  ip:port&#10;server_name localhost;&#9;                        #or domain or ip&#10;access_log  logs/localhost_access.log  main;&#9;#Change the log file name identifide by the servername&#10;error_log  logs/localhost_error.log;&#10;&#10;location / &#123;&#10;&#9;proxy_set_header Host $host;&#10;    proxy_set_header X-Forwarded-For $http_x_forwarded_for;&#10;    #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#10;    proxy_pass http://server_pool;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>upstream.conf</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool &#123;&#10;    #ip_hash;&#10;&#9;server&#9;realserver_ip_1:8080 weight=10 max_fails=2 fail_timeout=30s;&#10;&#9;server&#9;realserver_ip_2:8080 weight=10 max_fails=2 fail_timeout=30s;&#10;&#9;server&#9;realserver_ip_3:8080 weight=10 max_fails=2 fail_timeout=30s;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-03T06:39:09.000Z"><a href="/2016/06/03/sysbench配置和示例/">2016-06-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/03/sysbench配置和示例/">sysbench配置和示例</a></h1>
  

    </header>
    <div class="entry">
      
        <p>sysbench是一款评价操作系统性能的压测工具,主要用于数据库服务的性能压测.<br>本文简单介绍一些它的使用方法.</p>
<p><strong>压测性能参数</strong></p>
<ul>
<li>文件I/O性能</li>
<li>调度性能</li>
<li>内存分配和传输速度</li>
<li>线程执行性能</li>
<li>数据库服务性能</li>
</ul>
<p><strong>安装</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-devel</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/akopytov/sysbench.git</span><br><span class="line"><span class="built_in">cd</span> sysbench</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<p><strong>使用方法</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench [common-options] --test=name [<span class="built_in">test</span>-options] <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p>
<p><em>command说明</em></p>
<ul>
<li>prepare   执行准备动作,为fileio压测准备文件,为db压测准备测试数据</li>
<li>run          执行实际压测动作</li>
<li>cleanup   执行完成后清除临时数据</li>
<li>help      帮助信息</li>
</ul>
<p><em>options说明</em></p>
<ul>
<li>–num-threads         压测所用工作线程数,默认值1</li>
<li>–max-requests        请求数上限,0表示不限制,默认值10000</li>
<li>–max-time            执行时间上限,0表示不限制,默认值0</li>
<li>–thread-stack-size   每个线程的stack大小,默认值32K</li>
<li>–init-rng            压测之前是否初始化随机数生成器,默认off</li>
<li>–report-interval     统计信息显示时间间隔,默认0,不开启</li>
<li>–test            压测运行的名称,必须值</li>
<li>–debug           打印debug信息,默认off</li>
<li>–validate        压测结果确认,默认off</li>
<li>–help            打印帮助信息,默认off</li>
<li>–verbosity       信息显示等级,0-critical级信息,5-debug级信息,默认4</li>
<li>–percentile      sysbench执行时间包括请求的最短时间,平均时间,最长时间.此项可设置采用的请求百分比范围做统计,默认95</li>
</ul>
<p><strong>示例</strong></p>
<ul>
<li><p>cpu测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单线程</span></span><br><span class="line">sysbench --test=cpu --num-threads=<span class="number">1</span> --cpu-max-prime=<span class="number">5000</span> run</span><br><span class="line"><span class="comment">#多线程</span></span><br><span class="line">sysbench --test=cpu --num-threads=<span class="number">4</span> --cpu-max-prime=<span class="number">20000</span> run</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --test=memory --num-threads=<span class="number">1</span> --memory-block-size=<span class="number">4096</span> --memory-total-size=<span class="number">1</span>G run</span><br></pre></td></tr></table></figure>
</li>
<li><p>fileio测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#准备文件</span></span><br><span class="line">sysbench --test=fileio --file-total-size=<span class="number">400</span>M prepare</span><br><span class="line"><span class="comment">#随机读写模式</span></span><br><span class="line">sysbench --test=fileio --file-total-size=<span class="number">400</span>M --file-test-mode=rndrw --init-rng=on --max-time=<span class="number">300</span> --max-requests=<span class="number">0</span> run</span><br></pre></td></tr></table></figure>
</li>
<li><p>mysql测试(lua文件以sysbench源码实际路径为准)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#准备测试数据,创建表,插入100w数据</span></span><br><span class="line">sysbench --test=/usr/<span class="built_in">local</span>/src/sysbench/sysbench/tests/db/oltp.lua \</span><br><span class="line">              --mysql-host=host \</span><br><span class="line">              --mysql-port=<span class="number">9696</span> \</span><br><span class="line">              --mysql-user=kingshard \</span><br><span class="line">              --mysql-password=kingshard \</span><br><span class="line">              --mysql-db=kingshard \</span><br><span class="line">              --oltp-tables-count=<span class="number">1</span> \</span><br><span class="line">              --oltp-table-size=<span class="number">1000000</span> \</span><br><span class="line">              --num-threads=<span class="number">50</span> \</span><br><span class="line">              --max-requests=<span class="number">1000000</span> \</span><br><span class="line">              --report-interval=<span class="number">1</span> \</span><br><span class="line">              prepare</span><br><span class="line"><span class="comment">#测试select</span></span><br><span class="line">sysbench --test=/usr/<span class="built_in">local</span>/src/sysbench/sysbench/tests/db/select.lua \</span><br><span class="line">              --mysql-host=host \</span><br><span class="line">              --mysql-port=<span class="number">9696</span> \</span><br><span class="line">              --mysql-user=kingshard \</span><br><span class="line">              --mysql-password=kingshard \</span><br><span class="line">              --mysql-db=kingshard \</span><br><span class="line">              --oltp-tables-count=<span class="number">1</span> \</span><br><span class="line">              --oltp-table-size=<span class="number">1000000</span> \</span><br><span class="line">              --num-threads=<span class="number">16</span> \</span><br><span class="line">              --max-requests=<span class="number">1000000</span> \</span><br><span class="line">              --report-interval=<span class="number">1</span> \</span><br><span class="line">              --max-time=<span class="number">20</span> \</span><br><span class="line">              run</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考站点<br><a href="https://github.com/akopytov/sysbench" target="_blank" rel="external">https://github.com/akopytov/sysbench</a><br><a href="http://mingxinglai.com/cn/2013/07/sysbench/" target="_blank" rel="external">http://mingxinglai.com/cn/2013/07/sysbench/</a><br><a href="https://github.com/flike/kingshard/blob/master/doc/KingDoc/kingshard_performance_test.md" target="_blank" rel="external">https://github.com/flike/kingshard/blob/master/doc/KingDoc/kingshard_performance_test.md</a><br><a href="http://blog.csdn.net/lidan3959/article/details/36876517" target="_blank" rel="external">http://blog.csdn.net/lidan3959/article/details/36876517</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-31T09:53:20.000Z"><a href="/2016/05/31/使用Keepalived实现Redis高可用/">2016-05-31</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/31/使用Keepalived实现Redis高可用/">使用Keepalived实现Redis高可用</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文通过Keepalived配置和编写Redis切换脚本实现Redis服务的高可用,实现Redis主从的自动切换.</p>
<p>Redis和Keepalived的安装 略</p>
<p>实验环境如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Keepalived/Redis Master     192.168.10.12&#10;Keepalived/Redis Slave      192.168.10.13    &#10;VIP                         192.168.10.150</span><br></pre></td></tr></table></figure></p>
<p>Redis Master(192.168.10.12)上的Keepalived配置/etc/keepalived/keepalived.conf<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived&#10;global_defs &#123;&#10;    lvs_id LVS_redis&#10;&#125;&#10;vrrp_script chk_redis &#123;&#10;    script &#34;/etc/keepalived/scripts/redis_check.sh&#34;  &#10;    interval 2                                     &#10;&#125;&#10;vrrp_instance VI_1 &#123;&#10;    state BACKUP&#10;    interface eth1&#10;    virtual_router_id 51&#10;    priority 100&#10;    advert_int 1&#10;    nopreempt&#10;    authentication &#123;&#10;        auth_type PASS&#10;        auth_pass 1111&#10;    &#125;&#10;    track_script &#123;&#10;         chk_redis &#10;    &#125;&#10;    virtual_ipaddress &#123;&#10;        192.168.10.150&#10;    &#125;&#10;        notify_master &#34;/etc/keepalived/scripts/redis.sh -m&#34;&#10;        notify_backup &#34;/etc/keepalived/scripts/redis.sh -s&#34;&#10;        notify_fault  &#34;/etc/keepalived/scripts/redis.sh -s&#34;&#10;        notify_stop  &#34;/etc/keepalived/scripts/redis.sh -s&#34;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>各脚本文件按照实际情况配置:</p>
<p><strong>redis_check.sh</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash &#10;REDISCLI=/usr/local/bin/redis-cli&#10;REDISPORT=6379&#10;ALIVE=`$REDISCLI -p $REDISPORT PING` &#10;if [ &#34;$ALIVE&#34; == &#34;PONG&#34; ]; then&#10;echo $ALIVE &#10;exit 0 &#10;else&#10;echo $ALIVE &#10;exit 1 &#10;fi</span><br></pre></td></tr></table></figure></p>
<p><strong>redis.sh</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash&#10;#&#10;#Script start Redis and promote to MASTER/SLAVE&#10;#(The MIT License)&#10;#Copyright (C) 2011 Alex Williams&#10;#Modified by wong 2016&#10;#&#10;# Usage Options:&#10;#   -m    promote the redis-server to MASTER&#10;#   -s    promote the redis-server to SLAVE&#10;#   -k    start the redis-server and promote it to MASTER&#10;#&#10;#########################&#10;# User Defined Variables&#10;#########################&#10;REDIS_PEER_IP=&#34;192.168.10.13&#34;                                       # Redis MASTER ip&#10;REDIS_PORT=&#34;6379&#34;                                                   # Redis MASTER port&#10;REDIS_COMMANDS=&#34;/usr/local/bin/redis-cli -p $REDIS_PORT&#34;            # The location of the redis binary&#10;DAEMON=/usr/local/bin/redis-server&#10;DAEMON_ARGS=/etc/redis/$&#123;REDIS_PORT&#125;.conf&#10;##############&#10;# Exit Codes&#10;##############&#10;E_INVALID_ARGS=65&#10;E_INVALID_COMMAND=66&#10;E_NO_SLAVES=67&#10;E_DB_PROBLEM=68&#10;##########################&#10;# Script Functions&#10;##########################&#10;error() &#123;&#10;        E_CODE=$?&#10;        echo &#34;Exiting: ERROR $&#123;E_CODE&#125;: $E_MSG&#34;&#10;        exit $E_CODE&#10;&#125;&#10;start_redis() &#123;&#10;      alive=`$&#123;REDIS_COMMANDS&#125; PING`&#10;      if [ &#34;$alive&#34; != &#34;PONG&#34; ]; then&#10;        $&#123;DAEMON&#125; $&#123;DAEMON_ARGS&#125;&#10;        sleep 1&#10;      fi&#10;&#125;&#10;start_master() &#123;&#10;    $&#123;REDIS_COMMANDS&#125; SLAVEOF $&#123;REDIS_PEER_IP&#125; $&#123;REDIS_PEER_PORT&#125;&#10;    sleep 10&#10;        $&#123;REDIS_COMMANDS&#125; SLAVEOF no one&#10;&#125;&#10;start_slave() &#123;&#10;        $&#123;REDIS_COMMANDS&#125; SLAVEOF $&#123;REDIS_PEER_IP&#125; $&#123;REDIS_PORT&#125;&#10;&#125;&#10;usage() &#123;&#10;        echo  &#34;Start Redis and promote to MASTER/SLAVE  &#34;&#10;        echo  &#34;Options: &#34;&#10;        echo  &#34;-m promote the redis-server to MASTER&#34;&#10;        echo  &#34;-s promote the redis-server to SLAVE&#34;&#10;        echo  &#34;-k start the redis-server and promote it to MASTER&#34;&#10;        echo  &#34;&#34;&#10;        exit $E_INVALID_ARGS&#10;&#125;&#10;for arg in &#34;$@&#34;&#10;do&#10;        case $arg in&#10;        -m) arg_m=true;;&#10;        -s) arg_s=true;;&#10;        -k) arg_k=true;;&#10;        *) usage;;&#10;        esac&#10;done&#10;if [ $arg_m ]; then&#10;        echo  &#34;Promoting redis-server to MASTER&#34;&#10;        start_redis&#10;        wait&#10;        start_master&#10;elif [ $arg_s ]; then&#10;        echo  &#34;Promoting redis-server to SLAVE&#34;&#10;        start_redis&#10;        wait&#10;        start_slave&#10;elif [ $arg_k ]; then&#10;        echo  &#34;Starting redis-server and promoting to MASTER&#34;&#10;        start_redis&#10;        wait&#10;        start_master&#10;else&#10;        usage&#10;fi</span><br></pre></td></tr></table></figure></p>
<p>Redis Slave(192.168.10.13)上的Keepalived配置/etc/keepalived/keepalived.conf<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived&#10;global_defs &#123;&#10;    lvs_id LVS_redis&#10;&#125;&#10;vrrp_script chk_redis &#123;&#10;    script &#34;/etc/keepalived/scripts/redis_check.sh&#34;  &#10;    interval 2                                     &#10;&#125;&#10;vrrp_instance VI_1 &#123;&#10;    state BACKUP&#10;    interface eth1&#10;    virtual_router_id 51&#10;    priority 90&#10;    advert_int 1&#10;    authentication &#123;&#10;        auth_type PASS&#10;        auth_pass 1111&#10;    &#125;&#10;    track_script &#123;&#10;         chk_redis &#10;    &#125;&#10;    virtual_ipaddress &#123;&#10;        192.168.10.150&#10;    &#125;&#10;    notify_master &#34;/etc/keepalived/scripts/redis.sh -m&#34;&#10;    notify_backup &#34;/etc/keepalived/scripts/redis.sh -s&#34;&#10;    notify_fault  &#34;/etc/keepalived/scripts/redis.sh -s&#34;&#10;    notify_stop  &#34;/etc/keepalived/scripts/redis.sh -s&#34;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Redis Slave上的redis_check.sh与Redis Master上的一致,redis.sh不同的地方只有ip</p>
<p>备注<br>1 由于keepalived两个都设置了backup,并且是非抢占模式,启动keepalived的前提是:<br>(1) 保持redis主从数据一致.<br>2 脚本中redis-cli的指令需要用绝对路径,或者在脚本中加载环境变量,否则脚本无法生效.<br>3 停掉keepalived或redis都会导致vip的漂移.</p>
<p>参考站点<br><a href="https://aricgardner.com/databases/redis/redis-with-replication-and-failover-keepalived/" target="_blank" rel="external">https://aricgardner.com/databases/redis/redis-with-replication-and-failover-keepalived/</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-31T03:56:01.000Z"><a href="/2016/05/31/kingshard文档笔记记录/">2016-05-31</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/31/kingshard文档笔记记录/">kingshard文档笔记记录</a></h1>
  

    </header>
    <div class="entry">
      
        <p>安装golang<br>配置文件默认读取/etc/ks.yaml,启动的时候可以指定./bin/kingshard -config=etc/ks.yaml<br>配置文件是yaml方式解析,不允许出现tab健,且冒号后跟空格.<br>yaml文件验证网站<a href="http://www.yamllint.com/" target="_blank" rel="external">http://www.yamllint.com/</a></p>
<p>分表规则:<br>支持两种分表规则: hash和range<br>分表所涉及到的子表,需要手动创建好.格式为: table<em>name</em>%4d<br>未分表的SQL语句将发送到默认节点.</p>
<p>后台运行kingshard建议使用supervisor工具</p>
<p>当更新操作涉及到多个node时,kingshard会以非事务的方式执行跨node操作.为了保证数据一致性,请根据实际需求使用非事务方式的跨node更新操作.</p>
<p>可以指定sql发送的node,需要在sql语句前面加上包含node名称的注释(mysql在连接时需要加上-c选项,避免客户端过滤掉注释)</p>
<p>强制读主库<br>有时候主库插入数据后,希望立即从主库读出,可以在select语句中加入相应的注释项(/<em>master</em>/),就可以将select语句发送到主库.</p>
<p>支持跨node的sum和count函数</p>
<p>支持跨node的order by语句</p>
<p>支持单node的事务,出现跨node的事务,会返回错误.可以在同node上跨不同子表.</p>
<p>管理端命令以命令行方式提供,通过关键字标示,格式分两类<br>admin server(opt,k,v) values(action,k1,v1).操作整个kingshard,opt表示操作动作,k表示操作对象,v表示给对象的赋值.<br>admin node(opt,k,v) values(action,nodeName,k1,v1).表示操作node,opt表示操作动作,node表示节点,k表示操作对象,v表示对象赋值.<br>功能介绍: 平滑上下线后端DB,查看修改kingshard配置</p>
<p>kingshard分表方案采用二级映射的方式:<br>1 可以将表分为多个子表<br>2 将shardkey通过hash或range方式定位到其要操作的记录在哪张子表上<br>3 子表落在哪个node上通过配置文件设置</p>
<p>sharding支持insert,delete,select,update和replace语句,都支持跨子表.写操作只支持单node上跨子表.select可以跨node,跨子表.</p>
<p>sharding方式<br>range方式    基于整数范围划分来得到子表下标.基于范围的查询和更新速度快,存在热数据压力落到一张子表的问题.<br>hash方式    采用shardkey%子表个数的方式得到子表下标.请求分布均匀,基于范围的查询和更新,需要请求发送到所有子表,对性能有一定影响.</p>
<p>子表迁移方案<br>动态迁移子表,保证MySQL节点负载压力不要太大.<br>1 通过自动数据迁移工具<br>2 数据差异小于某一临界值,阻塞老子表写操作<br>3 等待新子表数据同步完毕<br>4 更改kingshard配置中对应子表路由规则<br>5 删除老节点子表</p>
<p>按时间分表<br>支持的MySQL时间类型<br>date类型:    格式YYYY-MM-DD<br>datetime类型:    格式YYYY-MM-DD HH:MM:SS<br>timestamp类型:    整数类型<br>配置文件示例<br>按年分表<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table: test_shard_year&#10;key: id&#10;type: date_year&#10;nodes: [node1,node2]&#10;date_range: [2015-2016,2017-2018]</span><br></pre></td></tr></table></figure></p>
<p>注意:    子表命名格式必须是shard_table_YYYY</p>
<p>按月分表<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table: test_shard_month&#10;key: ctime&#10;type: date_month&#10;nodes: [node1,node2]&#10;date_range: [201512-201602,201609-2016010]</span><br></pre></td></tr></table></figure></p>
<p>注意:    子表命名格式必须是shard_table_YYYYMM</p>
<p>按天分表<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table: test_shard_day&#10;key: ctime&#10;type: date_day&#10;nodes: [node1,node2]&#10;date_range: [20151222-20151224,20160901-20160902]</span><br></pre></td></tr></table></figure></p>
<p>注意:    子表命名格式必须是shard_table_YYYYMMDD</p>
<p>管理端命令<br>复用了工作端口,通过特定的关键字来标示,具体操作参考    <a href="https://github.com/flike/kingshard/blob/master/doc/KingDoc/admin_command_introduce.md" target="_blank" rel="external">管理端命令</a></p>
<p>SQL黑名单功能<br>可在配置中添加SQL黑名单功能<br>blacklist_sql_file: /Users/flike/blacklist<br>在blacklist文件中定义SQL黑名单即可<br>黑名单SQL以正则表达式的形式定义,SQL中的值用?或?+代替.使用前最好手动验证.<br>示例:<br>select count(<em>) from test_shard_hash where id &gt; ?(要严格匹配大于号后面的空格)<br>select count(</em>) from test_shard_range<br>SELECT * FROM WORLD<br>DELETE FROM WORLD</p>
<p>性能优化网络篇<br>通过go语言的pprof工具查看函数耗时情况<br>下载性能分析封装库profile<br>在main函数中添加cpu监控的启动和停止入口<br>使用sysbench进行压测<br>使用pprof生成pdf报告</p>
<p>参考站点:<br><a href="https://github.com/flike/kingshard/blob/master/README_ZH.md" target="_blank" rel="external">https://github.com/flike/kingshard/blob/master/README_ZH.md</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-30T01:57:09.000Z"><a href="/2016/05/30/使用expect实现交互批量执行指令/">2016-05-30</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/30/使用expect实现交互批量执行指令/">使用expect实现交互批量执行指令</a></h1>
  

    </header>
    <div class="entry">
      
        <p>使用expect实现交互执行shell命令</p>
<p>1 安装expect<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y expect</span><br></pre></td></tr></table></figure></p>
<p>2 expect.sh实现交互输入账户密码和需要执行的指令(以root账户为例)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect -f</span></span><br><span class="line"><span class="built_in">set</span> ip [lindex <span class="variable">$argv</span> <span class="number">0</span>]</span><br><span class="line"><span class="built_in">set</span> password [lindex <span class="variable">$argv</span> <span class="number">1</span>]</span><br><span class="line">spawn ssh root@<span class="variable">$ip</span></span><br><span class="line"><span class="built_in">set</span> timeout <span class="number">5</span></span><br><span class="line">expect <span class="string">"*yes/no)?"</span> &#123;send <span class="string">"yes\n"</span>&#125;</span><br><span class="line"><span class="built_in">set</span> timeout <span class="number">5</span></span><br><span class="line">expect <span class="string">"*assword:"</span> &#123;send <span class="string">"<span class="variable">$password</span>\n"</span>&#125;</span><br><span class="line"><span class="built_in">set</span> timeout <span class="number">5</span></span><br><span class="line">expect <span class="string">"#"</span></span><br><span class="line">send <span class="string">"ls\r"</span>    <span class="comment">#此处修改为实际需要的命令</span></span><br><span class="line"><span class="built_in">set</span> timeout <span class="number">5</span></span><br><span class="line">expect <span class="string">"#"</span></span><br><span class="line">send <span class="string">"exit\r"</span></span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure></p>
<p>3 执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x expect.sh</span><br><span class="line">./expect.sh ip password</span><br></pre></td></tr></table></figure></p>
<p>如果想多台服务器批量执行,可以把expect.sh嵌入到shell脚本中,做调用.</p>
<p>1 制作ip列表文件<br>ip.txt文件格式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip1:&#23494;&#30721;1&#10;ip2:&#23494;&#30721;2</span><br></pre></td></tr></table></figure></p>
<p>2 编写批量执行脚本list.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  ./expect.sh ` <span class="built_in">echo</span> <span class="variable">$line</span> | cut <span class="operator">-d</span><span class="string">":"</span> <span class="operator">-f</span>1` `<span class="built_in">echo</span> <span class="variable">$line</span> | cut <span class="operator">-d</span><span class="string">":"</span> <span class="operator">-f</span>2`</span><br><span class="line"><span class="keyword">done</span>&lt; ip.txt</span><br></pre></td></tr></table></figure></p>
<p>3 执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x list.sh</span><br><span class="line">./list.sh</span><br></pre></td></tr></table></figure></p>
<p>PS1: Python提供了一个pexpect库,实现相同的功能,具体实现可参阅参考站点连接<br>PS2: Python实现的Fabric功能更强大.<br>PS3: 一般我都是使用Ansible实现批量的自动化任务,Ansible 2.1发布了,开始支持网络设备的操作.</p>
<p>参考站点:<br><a href="http://blog.csdn.net/jaymade/article/details/7896847" target="_blank" rel="external">http://blog.csdn.net/jaymade/article/details/7896847</a><br><a href="https://segmentfault.com/q/1010000000133782" target="_blank" rel="external">https://segmentfault.com/q/1010000000133782</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-24T10:48:20.000Z"><a href="/2016/05/24/githug闯关记录/">2016-05-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/24/githug闯关记录/">githug闯关记录</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1 初始化git仓库<br>git init</p>
<p>2 配置git账户和邮箱<br>git config –global user.name “wfirooooooo”<br>git config –global user.email “parasiempre@126.com”</p>
<p>3 添加README文件到暂存区<br>git add README</p>
<p>4 提交README文件<br>git commit -m “add README”</p>
<p>5 clone一个git仓库<br>git clone <a href="https://github.com/Gazler/cloneme" target="_blank" rel="external">https://github.com/Gazler/cloneme</a></p>
<p>6 clone一个git仓库到指定文件夹<br>git clone <a href="https://github.com/Gazler/cloneme" target="_blank" rel="external">https://github.com/Gazler/cloneme</a> my_cloned_repo</p>
<p>7 git仓库忽略.swp文件<br>编辑.gitignore文件,添加以下内容<br>*.swp</p>
<p>8 git仓库忽略.a后缀的文件,但不包括lib.a<br>编辑.gitignore文件,添加以下内容<br>*.a<br>!lib.a</p>
<p>9 查找untracked的文件<br>git status</p>
<p>10 会被提交的文件数量<br>git status<br>备注: 只有前两个文件会被提交<br>untracked - 新增的文件.git不知道他们的存在<br>not staged - 被索引过又被修改的文件<br>staged - 通过git add后即将被提交的文件</p>
<p>11 从git仓库中删除已经在工作区中删除的文件<br>git status<br>git rm deleteme.rb</p>
<p>12 删除暂存区中的文件,而不要把文件从文件系统中删除,仅仅在git中删除<br>git status<br>git rm –cached deleteme.rb</p>
<p>13 保存修改的文件,稍后继续修改,但不提交<br>git stash<br>备注: 恢复文件使用git stash pop</p>
<p>14 修改oldfile.txt文件名为newfile.txt<br>git mv oldfile.txt newfile.txt</p>
<p>15 把git仓库中已有的文件重构到新的文件夹中<br>mkdir src<br>git mv *.html src/</p>
<p>16 查看代码提交日志<br> git log</p>
<p>17 给commit添加tag<br>git tag new_tag</p>
<p>18 推送tags到远程仓库<br>git push –tags</p>
<p>19 commit漏掉的文件,添加到上一次的commit中<br>git add forgotten_file.rb<br>git commit –amend</p>
<p>20 修改commit日期<br> git commit -m “commit next day” –date “2016-05-25 16:00:00”</p>
<p>21 使用reset命令把误添加的文件移出来<br>git status<br>git reset to_commit_second.rb<br>git status</p>
<p>22 撤回最后一次的提交,暂存区的索引不改<br>git reset HEAD~1 –soft</p>
<p>23 回滚config.rb为最后一次提交的内容<br>git checkout config.rb</p>
<p>24 把git仓库push到远端仓库<br>git remote</p>
<p>25 获取远端仓库的url<br>git remote -v</p>
<p>26 从初始仓库拉取变更<br>git pull origin master</p>
<p>27 给远端仓库origin添加url<br>git remote add origin <a href="https://github.com/githug/githug" target="_blank" rel="external">https://github.com/githug/githug</a></p>
<p>28 远端仓库已经重建主分支,提交到主分支并传到远端<br> git rebase origin/master<br>git push</p>
<p>29 查找commit过文件变化的行<br>git diff</p>
<p>30 查找文件最后的修改者<br>git blame config.rb</p>
<p>31 创建分支<br>git branch test_code</p>
<p>32 切换到新创建的分支<br>git checkout -b my_branch</p>
<p>33 在指定版本库上修改bug<br>git checkout v1.2</p>
<p>34 在有同名的tag和branch时,切换到tag需要显式表示(git认为分支的优先级更高)<br>git checkout tags/v1.2</p>
<p>35 忘记创建分支就提交了,创建一个提交前的分支(不包含最新一次提交的分支)<br>git branch test_branch HEAD~1</p>
<p>36 创建了过多的分支,删除无用的分支<br>git branch -d delete_me</p>
<p>37 本地分支提交的变更,不想合并到主分支,却希望分享出去<br>git push origin test_branch</p>
<p>38 把特性分支的文件合并到主分支<br>git merge feature</p>
<p>39 远程仓库更新的代码,只是查看,而不要合并到本地<br>git fetch origin</p>
<p>40 把feature分支rebase到master分支<br>git rebase master feature</p>
<p>41 优化仓库<br>git repack -d</p>
<p>42 删除特性分支,保留有用的commit内容<br>git log new-feature -p README.md<br>找到需要合并到主分支commit的hash值<br>git cherry-pick ca32a6dac7b6f97975edbe19a4296c2ee7682f68</p>
<p>43 deadline将至,查看有哪些TODO工作<br>git grep “TODO”</p>
<p>44 修改拼写错误的信息<br>git log –oneline<br>根据查询结果确定错误<br>git rebase -i HEAD~2<br>pick改为r<br>修改coommit为正确拼写<br>报错退出</p>
<p>45 合并多次提交为一次提交,在推送到远端仓库之前操作<br> git log –oneline<br>合并后3个到第二个commit<br>git rebase -i HEAD~4<br>2,3,4行的pick改为s<br>保存退出</p>
<p>46 合并特性分支时,所有提交合并为一个commit<br>git log long-feature-branch –oneline<br>git merge long-feature-branch –squash<br>git commit -m “merge long-feature-branch”</p>
<p>47 修改提交的顺序<br>git log –oneline 查看提交错误的顺序<br>git rebase -i HEAD~2    编辑互换错误的顺序</p>
<p>48 查找哪次commit提交了bug<br>git log –oneline 获得第一次提交的hash值<br>git bisect start HEAD f608824 开始调试<br>git bisect run make test    发现bug commit</p>
<p>49 修改了一个文件,此文件属于两个特性分支,只提交到第一个特性分支<br>git add feature.rb -p 手动编辑文件,删除其他feature内容<br>git status 查看状态</p>
<p>50 修改其他问题后,忘记先前工作的分支,如何找回这个分支<br>git reflog 查看先前工作得分支<br>git checkout solve_world_hunger</p>
<p>51 回滚某次提交<br>git log –oneline    找到需要回滚的提交hash<br>git revert 6c7a0a5</p>
<p>52 恢复删除的commit<br>git reflog    找到需要恢复的commit hash值<br>git cherry-pick bfd5f91</p>
<p>53 合并分支到主分支之前,需要修复错误和冲突<br>git merge mybranch 确定冲突文件<br>vim poem.txt    修改冲突文件,删除标识冲突的行<br>git add<br>git commit</p>
<p>54 想把一个远程仓库导入到工程文件夹中<br>git submodule add <a href="https://github.com/jackmaney/githug-include-me" target="_blank" rel="external">https://github.com/jackmaney/githug-include-me</a></p>
<p>参考站点<br><a href="https://codingstyle.cn/topics/181" target="_blank" rel="external">https://codingstyle.cn/topics/181</a><br><a href="http://fancyoung.com/blog/githug-cheat-sheet/" target="_blank" rel="external">http://fancyoung.com/blog/githug-cheat-sheet/</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-24T02:58:44.000Z"><a href="/2016/05/24/ActiveMQ高可用架构配置优化/">2016-05-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/24/ActiveMQ高可用架构配置优化/">ActiveMQ高可用架构配置优化</a></h1>
  

    </header>
    <div class="entry">
      
        <p>ActiveMQ是基于JAVA开发的一款开源消息队列软件.本文所述ActiveMQ架构为基于zookeeper实现高可用,基于LevelDB实现消息队列数据的持久化.</p>
<p>JDK安装,Zookeeper集群安装,ActiveMQ安装请参考其他文档,本文略.</p>
<p><strong>ActiveMQ配置优化</strong><br>1 调整默认的JVM内存<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#20462;&#25913;$activemq_home/bin/env&#10;&#40664;&#35748;&#20869;&#23481;&#10;ACTIVEMQ_OPTS_MEMORY=&#34;-Xms64M -Xmx1G&#34;&#10;&#20462;&#25913;&#20869;&#23481;(&#26681;&#25454;&#23454;&#38469;&#26381;&#21153;&#37197;&#32622;&#36827;&#34892;&#20462;&#25913;)&#10;ACTIVEMQ_OPTS_MEMORY=&#34;-Xms4G -Xmx8G&#34;</span><br></pre></td></tr></table></figure></p>
<p>2 调整activemq.xml文件<br>2.1 流量控制,不同队列分配不同内存使用上限,避免使用全局变量导致一个队列出现问题,影响其他队列运行.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#31034;&#20363;:&#10;&#60;policyEntry queue=&#34;*.VirtualTopic.Process.Result&#34; producerFlowControl=&#34;true&#34; memoryLimit=&#34;200mb&#34;/&#62;&#10;&#60;policyEntry queue=&#34;*.VirtualTopic.Process.Other&#34; producerFlowControl=&#34;true&#34; memoryLimit=&#34;20mb&#34;/&#62;</span><br></pre></td></tr></table></figure></p>
<p>2.2 systemUsage配置超时时间,单位为毫秒<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;systemUsage&#62;&#10; &#60;systemUsage sendFailIfNoSpaceAfterTimeout=&#34;3000&#34;&#62;&#10;   &#60;memoryUsage&#62;&#10;     &#60;memoryUsage percentOfJvmHeap=&#34;70&#34; /&#62;&#10;   &#60;/memoryUsage&#62;&#10; &#60;/systemUsage&#62;&#10;&#60;/systemUsage&#62;</span><br></pre></td></tr></table></figure></p>
<p>2.3 如果没有持久化需求,可以在broker中设置非持久化参数,提高性能<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;broker persistent=&#34;false&#34;&#62;&#10;&#60;/broker&#62;</span><br></pre></td></tr></table></figure></p>
<p>3 应用侧配置优化<br>3.1 设置TCP协议传输的socketBufferSize<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketBufferSize&#35745;&#31639;&#20844;&#24335;buffer_size = bandwidth * RTT&#10;&#31034;&#20363;: &#10;tcp://IP:61616?socketBufferSize=1500000(140K&#24038;&#21491;)</span><br></pre></td></tr></table></figure></p>
<p>3.2 配置Prefetch limit(消费者连接程序性能优化)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#31034;&#20363;:&#10;tcp://localhost:61616?jms.prefetchPolicy.queuePrefetch=1(&#23545;&#20110;&#19968;&#20010;&#38431;&#21015;,&#26377;&#19968;&#32452;&#28040;&#36153;&#32773;&#36830;&#25509;,&#20570;&#36127;&#36733;&#20998;&#25285;,&#20540;&#35774;&#20026;1&#25110;0)&#10;&#31034;&#20363;:&#10;queue = new ActiveMQQueue(&#34;TEST.QUEUE?consumer.prefetchSize=10&#34;);(&#23545;&#20110;&#19968;&#20010;&#38431;&#21015;,&#21482;&#26377;&#21333;&#29420;&#30340;&#28040;&#36153;&#32773;&#36830;&#25509;,&#20540;&#21487;&#20197;&#35774;&#32622;&#30340;&#22823;&#19968;&#20123;)&#10;consumer = session.createConsumer(queue);</span><br></pre></td></tr></table></figure></p>
<p>3.3 使用async模式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#31034;&#20363;:&#10;tcp://localhost:61616?jms.useAsyncSend=true</span><br></pre></td></tr></table></figure></p>
<p>参考站点<br><a href="http://blogs.sourceallies.com/2014/10/activemq-memory-tuning/" target="_blank" rel="external">http://blogs.sourceallies.com/2014/10/activemq-memory-tuning/</a><br><a href="http://www.mastertheintegration.com/core-apache-projects/activemq/introduction-to-activemq/tuning-activemq-tips.html" target="_blank" rel="external">http://www.mastertheintegration.com/core-apache-projects/activemq/introduction-to-activemq/tuning-activemq-tips.html</a><br><a href="http://blog.christianposta.com/activemq/speeding-up-activemq-persistent-messaging-performance-by-25x/" target="_blank" rel="external">http://blog.christianposta.com/activemq/speeding-up-activemq-persistent-messaging-performance-by-25x/</a><br><a href="http://www.cnblogs.com/bornteam/p/4462662.html" target="_blank" rel="external">http://www.cnblogs.com/bornteam/p/4462662.html</a><br><a href="http://manzuosteve.blog.51cto.com/1966239/1192190" target="_blank" rel="external">http://manzuosteve.blog.51cto.com/1966239/1192190</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-20T07:38:45.000Z"><a href="/2016/05/20/kingshard初体验/">2016-05-20</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/20/kingshard初体验/">kingshard初体验</a></h1>
  

    </header>
    <div class="entry">
      
        <p>kingshard是一种MySQL代理,用于实现读写分离和分库分表,以及一些其他功能.<br>由于其使用Golang开发,部署之前需要先安装Golang.<br>Golang版本在1.3以上即可,如果使用EPEL源,安装的就是Golang 1.5,满足要求.</p>
<p>epel源安装Golang<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure></p>
<p>kingshard编译安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/flike/kingshard.git /usr/<span class="built_in">local</span>/src/github.com/flike/kingshard</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/github.com/flike/kingshard</span><br><span class="line"><span class="built_in">source</span> ./dev.sh</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>kingshard配置<br>默认配置文件为/etc/ks.yaml,可以在启动的时候指定.<br><a href="https://github.com/flike/kingshard/blob/master/doc/KingDoc/kingshard_install_document.md" target="_blank" rel="external">配置文件说明</a></p>
<p>kingshard启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/kingshard</span><br><span class="line">./bin/kingshard -config etc/ks.yaml</span><br></pre></td></tr></table></figure></p>
<p>kingshard连接<br>默认端口是9696<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#账户名密码是kingshard配置中指定的账户密码</span></span><br><span class="line">mysql -uroot -p -hIP -P9696</span><br></pre></td></tr></table></figure></p>
<p>kingshard特点<br>创建分表后,插入和查询操作都会自动关联到分表中.<br>只支持带条件的查询.</p>
<p>参考站点<br><a href="https://github.com/flike/kingshard" target="_blank" rel="external">https://github.com/flike/kingshard</a><br><a href="http://www.ttlsa.com/kingshard/kingshard_quick_try/" target="_blank" rel="external">http://www.ttlsa.com/kingshard/kingshard_quick_try/</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-19T09:57:14.000Z"><a href="/2016/05/19/常用JVM性能调优监控工具示例/">2016-05-19</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/19/常用JVM性能调优监控工具示例/">常用JVM性能调优监控工具示例</a></h1>
  

    </header>
    <div class="entry">
      
        <p><strong>jps</strong><br>输出JVM中运行的状态信息<br>参数详解<br>-q 不输出类名、Jar名和传入main方法的参数<br>-m 输出传入main方法的参数<br>-l 输出main类或Jar的全限名<br>-v 输出传入JVM的参数<br>示例<br>jps -m -l</p>
<p><strong>jstack</strong><br>查看Java进程中的线程堆栈信息<br>参数详解<br>-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况<br>-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）<br>示例<br>jstack -l PID</p>
<p><strong>jmap和jhat</strong><br>jmap用于查看堆内存使用情况,一般结合jhat使用<br>参数详解<br>-histo[:live]        打印java对象堆直方图,如果带live参数,只打印存活的对象数量<br>-permstat            打印持久代统计信息<br>-finalizerinfo       打印等待终止对象信息<br>-dump:<dump-options> 输出hprof数据到指定文件<br>-J<flag>             标示运行时系统架构<br>示例<br>jmap -permstat pid    打印进程的类加载器和类加载器加载的持久代对象信息<br>jmap -heap pid    查看进程堆内存使用情况<br>jmap -histo[:live] pid    查看堆内存中的对象数目、大小统计直方图<br>jmap -dump:format=b,file=dumpFileName pid    把进程内存使用情况dump到文件中，再用jhat分析查看<br>jhat -J-mx512m -port 9998 dumpFileName</flag></dump-options></p>
<p>参考站点<br><a href="http://my.oschina.net/feichexia/blog/196575" target="_blank" rel="external">http://my.oschina.net/feichexia/blog/196575</a><br><a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html</a></p>
<p>have fun !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一頁</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜尋">
    <input type="hidden" name="q" value="site:wfirooooooo.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">標籤</h3>
  <ul class="entry">
  
    <li><a href="/tags/activemq/">activemq</a><small>1</small></li>
  
    <li><a href="/tags/ansible/">ansible</a><small>2</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>1</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/keepalived/">keepalived</a><small>1</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>1</small></li>
  
    <li><a href="/tags/lvs/">lvs</a><small>1</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>1</small></li>
  
    <li><a href="/tags/mha/">mha</a><small>1</small></li>
  
    <li><a href="/tags/mysql/">mysql</a><small>4</small></li>
  
    <li><a href="/tags/nfs/">nfs</a><small>1</small></li>
  
    <li><a href="/tags/nginx/">nginx</a><small>1</small></li>
  
    <li><a href="/tags/openvpn/">openvpn</a><small>1</small></li>
  
    <li><a href="/tags/redis/">redis</a><small>2</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>1</small></li>
  
    <li><a href="/tags/sysbench/">sysbench</a><small>1</small></li>
  
    <li><a href="/tags/tmux/">tmux</a><small>1</small></li>
  
    <li><a href="/tags/tomcat/">tomcat</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 wfir
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>